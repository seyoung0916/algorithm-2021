## 백준 1525 (퍼즐)
:pushpin: 유형
* BFS

:question: 문제
* 어떤 수와 인접한 네 개의 칸 중에 하나가 비어 있으면, 수를 이동 가능
* 초기 상태가 주어졌을 때, 정리된 상태로 만드는 것이 목표(오름차순)

:heavy_check_mark: 해결
* 0을 9로 치환하고 123456789가 될 때까지 반복
* 큐에 9자리 정수를 push하고 pop해서 과정을 반복
* 9의 위치를 문자에서 찾아 다음 위치의 인덱스를 구함  
  -> 현재 위치와 다음 인덱스의 값을 바꾸고 문자로 변환  
  -> 이전에 방문처리된 문자열이 아닌 경우(dic에 없음) 현재 문자의 이동 횟수에 1을 더해 새로 값을 넣음
* 큐가 비었는데 리턴되지 않은 경우 만들 수 없는 것이므로 -1 출력

:heavy_plus_sign: 추가
* 메모리 제한이 있어서 9자리 수를 한 번에 저장하지 않고 다 연결해 횟수와 함께 저장

---

## 백준 12851 (숨바꼭질 2)
:pushpin: 유형
* BFS

:question: 문제
* 수빈이의 현재 위치 N, 동생의 위치 K
* 수빈이는 걷거나(X-1, X+1) 순간이동(2*X) 가능
* 수빈이가 동생을 찾을 수있는 가장 빠른 시간이 몇 초 후인지 + 방법의 수 구하기

:heavy_check_mark: 해결
* 현재 지점에서 다음으로 움직 일 수 있는 점을 다시 큐에 넣음 -> 큐가 빌 때까지 반복
* 움직일 수 있는 범위 내인 경우  
  -> 방문하지 않았던 점이면 움직인 횟수 증가, 큐에 넣음  
  -> 다음 횟수가 이미 dist[다음 위치]에 저장되어 있으면 현재 cnt 값을 누적
* dist[k] : 이동의 최소 횟수, cnt[k] : 최소 횟수로 갈 수 있는 방법의 수
  
---

## 백준 11726 (2×n 타일링)
:pushpin: 유형
* DP

:question: 문제
* 2*n 크기의 직사각형을 1*2, 2*1 타일로 채우는 방법의 수

:heavy_check_mark: 해결
* 2*n 직사각형의 맨 오른쪽 끝에 가로 or 세로 타일이 올 수 있음
* 가로의 경우 2*(n-1)일 때의 방법의 수 + 세로의 경우 2*(n-2)일 때의 방법의 수  
  -> 피보나치의 공식을 적용

---

## 백준 15989 (1, 2, 3 더하기 4)
:pushpin: 유형
* DP

:question: 문제
* 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수

:heavy_check_mark: 해결
* 중복을 지원하지 않기 때문에 오름차순으로 정렬해 사용  
  -> 그렇지 않으면 수식이 중복될 수 있음
* dp[n][i] : n을 만드는데 끝에 더해지는 숫자가 i인 경우
* 4를 예시  
  -> 끝에 1이 더해지고 오름차순이려면 dp[3][1]의 경우밖에 없음
  -> 끝에 2이 더해지는 경우 : dp[2][1] + dp[2][2]
  -> 끝에 3이 더해지는 경우 : dp[1][1]
* 5 예시  
  -> 끝에 1이 더해지고 오름차순이려면 dp[4][1]의 경우밖에 없음
  -> 끝에 2이 더해지는 경우 : dp[3][1] + dp[3][2]
  -> 끝에 3이 더해지는 경우 : dp[2][1] + dp[2][2]
* 점화식  
  -> dp[n][1] = dp[n-1][1]  
  -> dp[n][2] = dp[n-2][1] + dp[n-2][2]  
  -> dp[n][3] = dp[n-3][1] + dp[n-3][2] + dp[n-3][3]

---