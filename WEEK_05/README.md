## 프로그래머스 43165 (타겟 넘버)
:pushpin: 유형
* DFS

:question: 문제
* numbers 배열의 숫자를 적절히 더하고 빼서 타겟 넘버 target을 만드는 방법의 수

:heavy_check_mark: 해결
* idx는 numbers의 인덱스, res는 현재까지의 합
* idx를 1씩 증가시키고, res에 현재 원소값을 더하거나 뺀 경우로 재귀 호출
* numbers 배열을 다 조회했을 경우 타겟넘버인지 체크하고 종료
  
---

## 프로그래머스 43162 (네트워크)
:pushpin: 유형
* DFS

:question: 문제
* 컴퓨터의 연결 정보 이차원 배열 computers가 주어질 때,네트워크의 개수 구하기
* A <-> B, B <-> C일 때, A <-> C는 간접적으로 연결된 것

:heavy_check_mark: 해결
* 방문했는지 체크할 배열 visited
* n만큼 돌면서 방문하지 않은 k 컴퓨터에 대해 dfs 함수를 실행
* 매개변수 i를 방문처리 하고, i와 연결된 컴퓨터 중 방문하지 않은 컴퓨터에 대해 dfs 실행
* 다음 연결된 컴퓨터가 없어 dfs가 끝난 경우 네트워크가 하나 생성되게 됨
  
---

## 백준 1748 (수 이어쓰기 1)
:pushpin: 유형
* 브루트포스

:question: 문제
* N이 주어질 때, 1부터 N까지 이어쓴 경우 몇 자리 수인지 구하기

:heavy_check_mark: 해결
* num 배열에 n의 길이보다 1 작은 숫자의 범위의 개수 구하기
  -> 120이면 두 자리 수까지, 한자리는 9개, 두자리는 90개 등등
* 나머지 숫자 범위의 시작점 구하기 (120이면 100)
  -> 10의 len(str(n))-1승
* 위에 구한 시작점부터 n까지의 개수*n의 자리수 + num 배열 원소*해당 범위의 자리수(원소의 인덱스+1)
  
---

>> sample

## 백준 10156 (과자)
:pushpin: 유형
* 시뮬레이션

:question: 문제
* K: 과자 가격, N: 사려는 과자 개수, M: 현재 가진 돈
* 과자를 사려할 때 부모님한테 받아야 하는 돈 계산(부족할 때)

:heavy_check_mark: 해결  
* C연산을 행<->열을 통해 같은 R연산으로 해줌

:heavy_plus_sign: 추가
* 연산을 하면서 기존 열 개수 값을 바꿔버려 틀림
  => tmpCol을 만들어 연산이 끝날 때 열 개수를 바꿔 해결
  
---  