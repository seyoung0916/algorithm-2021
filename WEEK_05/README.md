## 프로그래머스 43165 (타겟 넘버)
:pushpin: 유형
* DFS

:question: 문제
* numbers 배열의 숫자를 적절히 더하고 빼서 타겟 넘버 target을 만드는 방법의 수

:heavy_check_mark: 해결
* idx는 numbers의 인덱스, res는 현재까지의 합
* idx를 1씩 증가시키고, res에 현재 원소값을 더하거나 뺀 경우로 재귀 호출
* numbers 배열을 다 조회했을 경우 타겟넘버인지 체크하고 종료
  
---

## 프로그래머스 43162 (네트워크)
:pushpin: 유형
* DFS

:question: 문제
* 컴퓨터의 연결 정보 이차원 배열 computers가 주어질 때,네트워크의 개수 구하기
* A <-> B, B <-> C일 때, A <-> C는 간접적으로 연결된 것

:heavy_check_mark: 해결
* 방문했는지 체크할 배열 visited
* n만큼 돌면서 방문하지 않은 k 컴퓨터에 대해 dfs 함수를 실행
* 매개변수 i를 방문처리 하고, i와 연결된 컴퓨터 중 방문하지 않은 컴퓨터에 대해 dfs 실행
* 다음 연결된 컴퓨터가 없어 dfs가 끝난 경우 네트워크가 하나 생성되게 됨
  
---

## 백준 14500 (테트로미노)
:pushpin: 유형
* 브루트포스

:question: 문제
* 테트로미노를 N*M의 종이 위에 올릴 때 최댓값이 되는 수를 출력
* 회전이나 대칭 가능

:heavy_check_mark: 해결
* 테트로미노의 x, y를 미리 저장 (19가지)
* 입력받은 배열의 모든 원소를 기준으로 최대인 경우를 찾음 (count 함수)
* 미리 입력한 tetronomino 배열을 사용해 다음 위치의 값을 더하고 범위에 벗어나면 break
* try, except를 통해 에러를 처리함

---  

## 백준 1748 (수 이어쓰기 1)
:pushpin: 유형
* 브루트포스

:question: 문제
* N이 주어질 때, 1부터 N까지 이어쓴 경우 몇 자리 수인지 구하기

:heavy_check_mark: 해결
* num 배열에 n의 길이보다 1 작은 숫자의 범위의 개수 구하기
  -> 120이면 두 자리 수까지, 한자리는 9개, 두자리는 90개 등등
* 나머지 숫자 범위의 시작점 구하기 (120이면 100)
  -> 10의 len(str(n))-1승
* 위에 구한 시작점부터 n까지의 개수*n의 자리수 + num 배열 원소*해당 범위의 자리수(원소의 인덱스+1)
  
---

## 백준 2606 (바이러스)
:pushpin: 유형
* DFS

:question: 문제
* 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결된 모든 컴퓨터가 웜 바이러스에 걸림
* 1번 컴퓨터가 웜 바이러스에 걸림
* 컴퓨터의 수와 네트워크 상에 서로 연결된 정보가 주어질 때 1번 컴퓨터를 통해 바이러스에 걸리는 컴퓨터 수를 출력

:heavy_check_mark: 해결
* 이중배열로 컴퓨터의 연결 정보를 net에 저장
* 1번 컴퓨터부터 dfs 실행
* dfs
  => 방문 처리를 하고(visited) answer 1증가
  => idx와 연결된 컴퓨터 중 방문처리 안된 컴퓨터에 대해 dfs 실행
* answer은 1번 컴퓨터가 포함되어 있으므로 1빼서 출력

---  