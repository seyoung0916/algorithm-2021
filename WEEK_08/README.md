## 프로그래머스 72410 (신규 아이디 추천)
:pushpin: 유형
* 문자열
* 정규표현식

:question: 문제
* 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력한 경우,
  입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램
* 아이디 규칙
  -> 길이 3~15글자
  -> 알파벳 소문자, 숫자, -, _, .만 사용 가능
  -> .는 처음과 끝 사용불가, 연속 사용 불가
* 판별 과정
  -> 모든 문자를 소문자로 치환
  -> 입력 가능한 문자를 제외하고 다 제거
  -> .이 두 번 연속이면 .으로 치환
  -> .이 처음과 끝에 있으면 제거
  -> 새로운 아이디가 빈 문자열이면 a로 치환
  -> 길이 조건에 안 맞으면 첫 15글자를 제외 -> 마침표가 끝에 있으면 제거
  -> 2글자 이하이면 마지막 문자를 길이가 3될 때까지 반복

:heavy_check_mark: 해결
* string.lower() : 소문자 변환, upper() : 대문자 변환
* 입력 가능한 문자 체크
* answer를 ''로 리셋하고, 추가해야 할 문자가 .이고 answer가 존재할 때의 마지막 문자가 .인 경우 패스
* 양끝 . 제거
* 빈문자열인 경우 a로 초기화
* 길이체크 및 . 제거
* 길이가 2이하인 경우 3이될 때까지 마지막 문자 복제

:heavy_plus_sign: 추가
* 정규표현식을 사용해 훨씬 간단하게 개발 가능
* ^a-z0-9\-_. : 소문자, 숫자, 문자표시(\)-_.을 제외한 문자가 나오는 경우 ''로 대체
* \.+ : .이 한 번 이상 반복되는 경우, *은 0번 이상
* ^[.]|[.]$ : 시작이나 끝에 .이 있는 경우
  
---

## 프로그래머스 72411 (메뉴 리뉴얼)
:pushpin: 유형
* json 처리

:question: 문제
* 단품을 묶어 세트메뉴 구성
* 이전에 각 손님들이 가장 많이 주문한 단품메뉴들을 코스요리 메뉴로 구성
* 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 후보에 포함
* course : 세트의 단품메뉴 개수 제한
* 같은 메뉴 개수이면 가장 많이 주문된 조합을 answer에 넣으면 됨
* 오름차순으로 출력

:heavy_check_mark: 해결
* orders 원소들에서 course 원소의 수에 대해 조합을 구하고 combi에 넣음
  -> combi에는 course의 원소별 가능한 조합이 들어가게 됨
* 가능한 조합에 대한 주문 건수를 구함
  -> 각 메뉴에 g(조합 가능 건수)의 원소가 다 포함된 경우 주문된 것이므로 cnt+1
  -> 모든 메뉴를 검사했을 때 주문 건수가 2 이상이면 count 딕셔너리에 넣고 max_cnt값 갱신
* count에 course 원소별 조합에 대한 주문 건수가 들어있음
  -> max_cnt를 value로 가진 딕셔너리 key를 answer에 넣어주면 됨 
  
:heavy_plus_sign: 추가
* course에 속하는 모든 조합을 구한 뒤에 가장 많이 출현한 메뉴 선정 -> 시간복잡도 증가
  => 주문한 메뉴에서 가능한 조합을 추려내는 것으로 변경
  
---

-> 예제

## 인프런 문제 2 (JAVA독과 함께!)
:pushpin: 유형
* json 처리

:question: 문제
* 징검다리를 건널 때, 돌의 몸무게만큼 내구도가 떨어짐
* 독들마다 점프력이 다름
* 생존자를 구하기

:heavy_check_mark: 해결
* answer에 독의 이름을 넣어줌
* dog의 원소 독을 차례로 돌을 건넘
  -> 현재 위치를 0으로 초기화
  -> 징검다리를 벗어날 때까지 반복
  -> 해당 독의 점프력만큼 현재 위치를 더해줌추
  -> 해당 돌의 내구도를 몸무게만큼 감소시킴 (시작점에서 두 칸 뛰면 인덱스 1의 돌에 도착)
  -> 돌의 내구도가 음수가 되면 answer에서 해당 독의 이름을 제거
  
:heavy_plus_sign: 추가
* 리스트 연산 remove : O(N), del : O(1)
  
---