## 프로그래머스 72410 (신규 아이디 추천)
:pushpin: 유형
* 문자열
* 정규표현식

:question: 문제
* 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력한 경우, <br>
  입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램
* 아이디 규칙 <br>
  -> 길이 3~15글자 <br>
  -> 알파벳 소문자, 숫자, -, _, .만 사용 가능 <br>
  -> .는 처음과 끝 사용불가, 연속 사용 불가
* 판별 과정 <br>
  -> 모든 문자를 소문자로 치환 <br>
  -> 입력 가능한 문자를 제외하고 다 제거 <br>
  -> .이 두 번 연속이면 .으로 치환 <br>
  -> .이 처음과 끝에 있으면 제거 <br>
  -> 새로운 아이디가 빈 문자열이면 a로 치환 <br>
  -> 길이 조건에 안 맞으면 첫 15글자를 제외 -> 마침표가 끝에 있으면 제거 <br>
  -> 2글자 이하이면 마지막 문자를 길이가 3될 때까지 반복

:heavy_check_mark: 해결
* string.lower() : 소문자 변환, upper() : 대문자 변환
* 입력 가능한 문자 체크
* answer를 ''로 리셋하고, 추가해야 할 문자가 .이고 answer가 존재할 때의 마지막 문자가 .인 경우 패스
* 양끝 . 제거
* 빈문자열인 경우 a로 초기화
* 길이체크 및 . 제거
* 길이가 2이하인 경우 3이될 때까지 마지막 문자 복제

:heavy_plus_sign: 추가
* 정규표현식을 사용해 훨씬 간단하게 개발 가능
* ^a-z0-9\-_. : 소문자, 숫자, 문자표시(\)-_.을 제외한 문자가 나오는 경우 ''로 대체
* \.+ : .이 한 번 이상 반복되는 경우, *은 0번 이상
* ^[.]|[.]$ : 시작이나 끝에 .이 있는 경우
  
---

## 프로그래머스 72411 (메뉴 리뉴얼)
:pushpin: 유형
* 조합
* 자료구조

:question: 문제
* 단품을 묶어 세트메뉴 구성
* 이전에 각 손님들이 가장 많이 주문한 단품메뉴들을 코스요리 메뉴로 구성
* 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 후보에 포함
* course : 세트의 단품메뉴 개수 제한
* 같은 메뉴 개수이면 가장 많이 주문된 조합을 answer에 넣으면 됨
* 오름차순으로 출력

:heavy_check_mark: 해결
* orders 원소들에서 course 원소의 수에 대해 조합을 구하고 combi에 넣음 <br>
  -> combi에는 course의 원소별 가능한 조합이 들어가게 됨
* 가능한 조합에 대한 주문 건수를 구함 <br>
  -> 각 메뉴에 g(조합 가능 건수)의 원소가 다 포함된 경우 주문된 것이므로 cnt+1 <br>
  -> 모든 메뉴를 검사했을 때 주문 건수가 2 이상이면 count 딕셔너리에 넣고 max_cnt값 갱신
* count에 course 원소별 조합에 대한 주문 건수가 들어있음 <br>
  -> max_cnt를 value로 가진 딕셔너리 key를 answer에 넣어주면 됨 
  
:heavy_plus_sign: 추가
* course에 속하는 모든 조합을 구한 뒤에 가장 많이 출현한 메뉴 선정 -> 시간복잡도 증가 <br>
  => 주문한 메뉴에서 가능한 조합을 추려내는 것으로 변경
  
---

## 프로그래머스 72412 (순위 검색)
:pushpin: 유형
* 구현

:question: 문제
* info : 지원자가 지원서에 입력한 4가지 정보 + 코딩테스트 점수
* query : 개발팀이 궁금해하는 문의조건
* 각 문의조건에 해당하는 사람들의 숫자를 순서대로 return

:heavy_check_mark: 해결
* all 딕셔너리 : 지원자들의 조건을 키로 가지고 value에 코테 점수가 리스트로 있음
* make_cases : 각 지원자의 조건에 대해 나올 수 있는 경우의 수를 모두 구함 <br>
  -> split한 지원자의 정보에 0, 1, 2, 3 인덱스 중 무작위로 0~4개를 뽑아 -를 조건으로 변경 <br>
  -> 총 16가지의 경우가 나옴
* make_senses로 나온 값을 all의 키값으로 설정하고, 코테 점수를 value로 list 쌓음
* all.keys()에 대해 value를 오름차순으로 정렬
* 각 쿼리들을 split하여 all의 key와 일치하게 만듦 <br>
  -> 일치하는 key가 있으면 bisect_left를 사용해 쿼리의 점수 이후의 개수를 세서 answer에 넣음 <br>
  -> 없으면 0을 넣음
  
:heavy_plus_sign: 추가
* info의 정보를 split해서 split한 쿼리와 일치하는지 + 점수 체크 <br>
  -> 최악의 경우 5만(지원자 수) * 5(조건 수) * 10만(쿼리) <br>
  => 효율성 0점 
* info에서 각 지원자에게 나올 수 있는 검색 조건을 만들어 비교 <br>
  -> 2*2*2*2 * 쿼리 수 로 시간이 훨씬 줄어듬
* key에 대한 value에서 쿼리의 점수 이상인 것을 세면 시간초과 <br>
  -> bisect_left를 사용해 특정 원소를 찾아 그 이후의 개수를 세서 시간 단축
  
---

## 백준 11047 (동전 0)
:pushpin: 유형
* 그리디

:question: 문제
* 준규가 가진 동전 N 종류
* 동전을 사용해 K원을 만들 때 필요한 동전 개수의 최솟값

:heavy_check_mark: 해결
* 명시된 조건에 따라 큰 동전이 작은 동전의 배수가 됨
* 입력받은 동전의 역순으로 몫을 구해서 딕셔너리에 저장

---